
################################## SSL ##########################
function checkSSL(url) {
    // Создаем XMLHttpRequest для выполнения HTTPS-запроса
    const xhr = new XMLHttpRequest();
    xhr.open('HEAD', url, true);
    xhr.onload = function () {
      // Получаем информацию о сертификате
      const cert = xhr.getResponseHeader('x509-issuer');
      const expires = xhr.getResponseHeader('expires');
      const subject = xhr.getResponseHeader('x509-subject');
      // Создаем всплывающее окно для вывода информации о сертификате
      const popup = window.open('', 'sslPopup', 'width=400,height=300');
      popup.document.write(`
        <h1>SSL Certificate Information</h1>
        <p>Subject: ${subject}</p>
        <p>Issuer: ${cert}</p>
        <p>Expiration Date: ${expires}</p>
      `);
    };
    xhr.send();
}

###########################################################################

// Функция для выполнения запроса на сервер и получения информации о хосте
function getServerHost(ipAddress) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', `https://reverse-ip-api.com/json/${ipAddress}`, true);
    xhr.onreadystatechange = () => {
      if (xhr.readyState === XMLHttpRequest.DONE) {
        if (xhr.status === 200) {
          try {
            const response = JSON.parse(xhr.responseText);
            const serverHost = response.host || 'Unknown';
            resolve(serverHost);
          } catch (error) {
            reject(error);
          }
        } else {
          reject(new Error(`Failed to get server host. Status code: ${xhr.status}`));
        }
      }
    };
    xhr.send();
  });
}

// Пример использования функции
const ipAddress = '123.45.67.89'; // IP-адрес сервера
getServerHost(ipAddress)
.then(serverHost => {
  console.log(`Server host for IP address ${ipAddress}: ${serverHost}`);
})
.catch(error => {
  console.error(`Failed to get server host for IP address ${ipAddress}:`, error);
});


// Загрузка библиотеки jsrsasign (https://kjur.github.io/jsrsasign/)
const script = document.createElement('script');
script.src = 'https://kjur.github.io/jsrsasign/jsrsasign-latest-all-min.js';
script.onload = function() {
  // Функция для проверки SSL-сертификата
  function checkSSLCertificate(serverHost) {
    const certPEM = `-----BEGIN CERTIFICATE-----
                      // Ваш SSL-сертификат в формате PEM
                      -----END CERTIFICATE-----`;
    const x509 = new X509();
    x509.readCertPEM(certPEM);
    const isValid = x509.checkHost(serverHost);
    return isValid;
  }

  // Пример использования функции
  const serverHost = 'example.com'; // Название веб-сервера (хоста)
  const isValid = checkSSLCertificate(serverHost);
  if (isValid) {
    console.log(`SSL certificate for ${serverHost} is valid.`);
  } else {
    console.error(`SSL certificate for ${serverHost} is invalid.`);
  }
};
document.head.appendChild(script);

############################################################################
// import forge from 'node-forge';

// const checkUrl = async (inputRef) => {
//     const tabs = await chrome.tabs.query({ currentWindow: true, active: true });
//     inputRef.current.value = tabs[0].url;

//     const domain = new URL(tabs[0].url).hostname;

//     const xhr = new XMLHttpRequest();
//     xhr.open('GET', `https://${domain || ip}`, true);
//     xhr.responseType = 'arraybuffer';

//     xhr.onload = async () => {
//         if (xhr.readyState === 4 && xhr.status >= 200 && xhr.status < 300) {
//             const certificate = new Uint8Array(xhr.response);
//             const x509 = forge.pki.certificateFromAsn1(forge.asn1.fromDer(String.fromCharCode.apply(null, certificate)));
//             const validFrom = x509.validity.notBefore;
//             const validTo = x509.validity.notAfter;
//             console.log(`Дата начала действия: ${validFrom}`);
//             console.log(`Дата окончания действия: ${validTo}`);
//         }
//     };

//     xhr.send();
// };

##################################################333

//&& !urls.includes(links[i].href)
&& !urls.includes(link.href)

########################################################3

// const API_KEY = 'e0a8f7cd2232d4c72afbcd214febcd02bc5ecf5ee4d37014e874e1a216f1170e'; 
// const API_URL = 'https://www.virustotal.com/vtapi/v2/url/report';
// const URLS_PER_REQUEST = 4; // Максимальное количество URL-адресов для каждого запроса
// const REQUESTS_PER_SECOND = 0.067; // Максимальное количество запросов в секунду

// // Функция для проверки списка URL-адресов
// const CheckSpamBD = async (urls) => {
//   const urlChunks = chunkUrls(urls, URLS_PER_REQUEST);

//   for (const chunk of urlChunks) {
//     const requestUrls = chunk.map((url) => ({ url }));
//     const requestBody = {
//       apikey: API_KEY,
//       resource: requestUrls.map(url => url.url).join('\n')
//     };

//     const response = await fetch(API_URL, {
//       method: 'POST',
//       body: JSON.stringify(requestBody),
//       headers: {
//         'Content-Type': 'application/json',
//       },
//     });

//     const result = await response.json();

//     for (const url in result) {
//       if (result[url].response_code === 1) {
//         console.log(`URL ${url} is listed as ${result[url].positives} positives out of ${result[url].total} scans`);
//       }
//     }
//   }
// };

// // Функция для разбиения списка URL-адресов на чанки
// const chunkUrls = (urls, chunkSize) => {
//   const chunks = [];
//   for (let i = 0; i < urls.length; i += chunkSize) {
//     chunks.push(urls.slice(i, i + chunkSize));
//   }
//   return chunks;
// };


// Функция отправки URL-адресов на Virustotal
const CheckSpamBD = (urls) => {
  // Проверяем, есть ли URL-адресы в массиве urls
  if (urls.length === 0) {
    console.log('Массив URL-адресов пуст.');
    return;
  }

  // Ограничение на количество запросов в минуту
  const requestsPerMinute = 4;
  const delayBetweenRequests = 60000 / requestsPerMinute;

  // Разбиваем массив на части (chunks) для последовательной отправки
  const chunkSize = 4;
  const chunks = [];
  for (let i = 0; i < urls.length; i += chunkSize) {
    chunks.push(urls.slice(i, i + chunkSize));
  }

  // Отправляем части (chunks) на Virustotal API
  let currentIndex = 0;
  const sendChunk = () => {
    if (currentIndex < chunks.length) {
      const currentChunk = chunks[currentIndex];
      currentChunk.forEach((url, index) => {
        // Задержка между запросами
        setTimeout(() => {
          fetch(`https://www.virustotal.com/api/v2/urls/${encodeURIComponent(url)}`, {
            method: 'GET',
            headers: {
              'x-apikey': 'e0a8f7cd2232d4c72afbcd214febcd02bc5ecf5ee4d37014e874e1a216f1170e' // Замените на свой ключ API от Virustotal
            }
          })
            .then(response => {
              if (response.ok) {
                return response.json();
              } else {
                throw new Error('Ошибка при отправке запроса на Virustotal API.');
              }
            })
            .then(data => {
              // Обработка ответа от Virustotal API
              console.log(`Ответ для URL-адреса ${url}:`, data);
            })
            .catch(error => {
              console.error(error);
            });

          // Переходим к следующему URL-адресу
          currentIndex += 1;
          // Вызываем функцию для отправки следующей части (chunk)
          sendChunk();
        }, index * delayBetweenRequests);
      });
    }
  };

  // Вызываем функцию для отправки первой части (chunk)
  sendChunk();
};

#####################################################################3
const axios = require('axios');

// Замените это значение своим API-ключом
const apiKey = 'YOUR_API_KEY';

// Отправка запросов на VirusTotal
async function checkUrls(urls) {
  let i = 0;
  const intervalId = setInterval(async () => {
    const url = urls[i];
    try {
      const response = await axios.get(`https://www.virustotal.com/api/v3/urls/${encodeURIComponent(url)}`, {
        headers: {
          'x-apikey': apiKey
        }
      });
      console.log(response.data);
    } catch (error) {
      console.error(error);
    }
    i++;
    if (i >= urls.length) {
      clearInterval(intervalId);
      console.log('Все запросы завершены');
    } else if (i % 4 === 0) {
      clearInterval(intervalId);
      setTimeout(() => checkUrls(urls.slice(i)), 60 * 1000); // Останавливаем выполнение цикла на 1 минуту и продолжаем с оставшимися URL-адресами
    }
  }, 15 * 1000); // Отправляем 4 запроса с задержкой в 15 секунд
}

// Пример использования функции
const urls = ['https://example.com', 'https://google.com', 'https://facebook.com', 'https://twitter.com', 'https://linkedin.com', 'https://instagram.com'];
checkUrls(urls);



import axios from 'axios';

const encodedParams = new URLSearchParams();
encodedParams.set('url', 'hgkj');

const options = {
  method: 'POST',
  url: 'https://www.virustotal.com/api/v3/urls',
  headers: {
    accept: 'application/json',
    'x-apikey': 'hkl',
    'content-type': 'application/x-www-form-urlencoded'
  },
  data: encodedParams,
};

axios
  .request(options)
  .then(function (response) {
    console.log(response.data);
  })
  .catch(function (error) {
    console.error(error);
  });



  import axios from 'axios';

const options = {
  method: 'GET',
  url: 'https://www.virustotal.com/api/v3/urls/id',
  headers: {accept: 'application/json', 'x-apikey': 'hk'}
};

axios
  .request(options)
  .then(function (response) {
    console.log(response.data);
  })
  .catch(function (error) {
    console.error(error);
  });


  for (let i = 0; i < links.length; i++) {
  if (links[i].href && !links[i].href.startsWith("chrome-extension://") && !URLS.includes(links[i].href)) {
    URLS.push(links[i].href);
    count++;
  }
}



№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№
let URLS = [];

const links = document.getElementsByTagName("a");
for (let i = 0; i < links.length; i++) {
    const href = links[i].getAttribute("href");
    if (href) {
        const url = new URL(href, tabs[0].url);
        const urlString = url.href;
        if (/^(http|https):\/\//.test(urlString) && !URLS.includes(urlString)) {
            URLS.push(urlString);
        }
    }
}
                // for (let i = 0; i < links.length; i++) {
                //     // const href = links[i].getAttribute("href");
                //     const href = links[i].href;
                //     if (href && /^(http|https):\/\//.test(href) && !URLS.includes(href)) {
                //         URLS.push(href);
                //         count++;
                //     }
                // }

                // for (let i = 0; i < links.length; i++) {
                //     const href = links[i].getAttribute("href");
                //     if (href && !URLS.includes(href)) {
                //         if (/^(http|https):\/\//.test(href)) {
                //             URLS.push(href);
                //         } else {
                //             URLS.push(new URL(href, tabs[0].url).href);
                //         }
                //         count++;
                //     }
                // }

const iframes = document.getElementsByTagName("iframe");
for (let i = 0; i < iframes.length; i++) {
    const src = iframes[i].getAttribute("src");
    if (src) {
        const url = new URL(src, tabs[0].url);
        const urlString = url.href;
        if (/^(http|https):\/\//.test(urlString) && !URLS.includes(urlString)) {
            URLS.push(urlString);
        }
    }
}
                // for (let i = 0; i < iframes.length; i++) {
                //     const src = iframes[i].getAttribute("src");
                //     if (src && /^(http|https):\/\//.test(src) && !URLS.includes(src)) {
                //         URLS.push(src);
                //         count++;
                //     }
                // }

const scripts = document.getElementsByTagName("script");
for (let i = 0; i < scripts.length; i++) {
    const src = scripts[i].getAttribute("src");
    if (src) {
        const url = new URL(src, tabs[0].url);
        const urlString = url.href;
        if (/^(http|https):\/\//.test(urlString) && !URLS.includes(urlString)) {
            URLS.push(urlString);
        }
    }
}
                // for (let i = 0; i < scripts.length; i++) {
                //     const src = scripts[i].getAttribute("src");
                //     if (src && /^(http|https):\/\//.test(src) && !URLS.includes(src)) {
                //         URLS.push(src);
                //         count++;
                //     }
                // }

const imgs = document.getElementsByTagName("img");
for (let i = 0; i < imgs.length; i++) {
    const src = imgs[i].getAttribute("src");
    if (src) {
        const url = new URL(src, tabs[0].url);
        const urlString = url.href;
        if (/^(http|https):\/\//.test(urlString) && !URLS.includes(urlString)) {
            URLS.push(urlString);
        }
    }
}
                // for (let i = 0; i < imgs.length; i++) {
                //     const src = imgs[i].getAttribute("src");
                //     if (src && /^(http|https):\/\//.test(src) && !URLS.includes(src)) {
                //         URLS.push(src);
                //         count++;
                //     }
                // }

console.log(URLS);
// sendCheckSpamBD(URLS);

#######################################################3

// Функция для отправки URL-адресов на VirusTotal
const sendCheckSpamBD = async (urls) => {
  // Проверяем, есть ли URL-адресы в массиве urls
  if (urls.length === 0) {
    console.log('Массив URL-адресов пуст.');
    return;
  }

  // Ограничение на количество запросов в минуту
  const requestsPerMinute = 4;
  const delayBetweenRequests = 60000 / requestsPerMinute;

  // Разбиваем массив URL-адресов на чанки (пакеты)
  const chunks = [];
  while (urls.length > 0) {
    chunks.push(urls.splice(0, requestsPerMinute));
  }

  let hasErrors = false; // Флаг наличия ошибок

  // Отправляем запросы на VirusTotal API последовательно с использованием чанков
  for (const chunk of chunks) {
    for (const url of chunk) {
      await new Promise(resolve => setTimeout(resolve, delayBetweenRequests)); // Задержка между запросами

      // Отправляем POST-запрос на VirusTotal API для добавления URL-адреса
      const encodedParams = new URLSearchParams();
      encodedParams.set('url', url);
      const options = {
        method: 'POST',
        url: 'https://www.virustotal.com/api/v3/urls',
        headers: {
          accept: 'application/json',
          'x-apikey': 'e0a8f7cd2232d4c72afbcd214febcd02bc5ecf5ee4d37014e874e1a216f1170e' // Замените на свой ключ API от VirusTotal
        },
        data: encodedParams
      };
      try {
        const response = await axios.request(options);
        console.log(`Ответ для URL-адреса ${url}:`, response.data);
      } catch (error) {
        console.error(`Ошибка при отправке запроса для URL-адреса ${url}:`, error);
        hasErrors = true;
      }
    }
  }

  if (hasErrors) {
    // Выводим сообщение об ошибке в popup
    alert('Возникла ошибка при отправке запросов на проверку URL-адресов.');
  } else {
    console.log('Все запросы на проверку URL-адресов были отправлены успешно.');
  }
};

